<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h2>Week Two</h2>

    <section>
        <h3>Programming Basics</h3>
        <p>
        <h4>Comments</h4>
        <strong>Notes:</strong>
        Multi-line comments start with /* and finish with */:
        <br>
        <h4>Block</h4>
        <strong>Notes:</strong>
        A block is a series of statements that are collected together inside curly braces
        <br>
        Blocks do not need to be terminated by a semicolon at the end.
        <br>
        <strong>Example:</strong>
        <br>
        Hello alert message that appear when the page is open
        <span class="blockStatement"></span>

        <h4>Data Types</h4>
        <strong>Notes:</strong>
        JavaScript has seven different data types.
        <br>
        Any value that is not one of the primitive data types listed above is an <strong>object</strong>.
        <br>
        <br>
        Six of them are primitive data types and
        are listed below:

        <li>String</li>
        <li>Symbol</li>
        <li>Number</li>
        <li>Boolean</li>
        <li>Undefined</li>
        <li>Null</li>

        <h4>Operator</h4>
        <strong>Notes:</strong>
        JavaScript has a special operator called <strong>typeof</strong>, for finding out the type of a value.<br>
        <strong>Example:</strong>
        <p class="typesOfOperators"></p>

        <h4>Variables</h4>
        <strong>Notes:</strong>
        If the variable references a non-primitive data type, such as an array, function or
        object, then using const will not make it immutable. This means the underlying
        data inside the object can change (known as mutating the object). We can see this
        in the example below:<br><br>
        const name = { value: 'Alexa' }; // an object
        <br><br>
        Any variable declared outside of a block is said to have global scope.<bR>
        If let or const are not used, the variable will have global scope

        <h4>Methods </h4>
        <strong>Notes:</strong><br>
        Write a string in all capital letters using the toUpperCase() method: <br>
        <span class="upper"></span>
        <br>
        The toLowerCase() method, which will write my name in all lower-case letters:<br>
        <span class="lower"></span>
        <br>
        To know which character is at a certain position, you can use the charAt() method: <br>
        <span class="position"></span>
        <br>
        (This tells us that the character ‘l’ in Alexa is at position 1.).
        <br><br>
        To find where a certain character or substring appears in a string, we can use the indexOf() method: <br>
        <span class="index1"></span>
        <br>
        <span class="index2"></span>
        <br>
        If a character doesn’t appear in the string, -1 will be returned: <br>
        <br>
        Want the last occurrence of a character or substring, we can use the lastIndexOf() method:
        <br>
        <span class="last"></span>
        <br>
        Want to know if a string contains a certain character, we can use the includes() method:
        <br>
        <span class="includes1"></span>
        <br>
        <span class="includes2"></span>
        <br>
        A couple of methods to check if a string starts or ends in a particular character. To check if a string
        starts with a certain character, we can use the startsWith() method.
        <br>
        <span class="starts1"></span>
        <br>
        <span class="starts2"></span>
        <br>
        (note: Be careful though, its case-sensitive)
        <br>
        And we can use the similar endsWith() method to check if a string ends with a particular character:<br>
        <span class="ends1"></span>
        <br>
        <span class="ends2"></span>
        <br>
        The concat() method can be used to concatenate two or more strings together:
        <br>
        <span class="concat1"></span>
        <br>
        <span class="concat2"></span>
        <br>
        A shortcut for string concatenation is to use the + operator to add the two strings together:
        <br>
        <span class="concat3"></span>
        <br>
        The trim() method will remove any whitespace from the beginning and end of a string:
        <br>
        <span class="trim1"></span>
        <br>
        <span class="trim2"></span>
        <br>
        The repeat() method that will repeat a string the stated number of times: <br>
        <span class="repeat"></span>


        <h4>Template Literals</h4>
        <strong>Notes:</strong>
        Use (\n): to make a line break

        <h4>Symbols</h4>
        Ex.<br>
        const uniqueID = Symbol('this is a unique ID');<br><br>
        The main use-case for symbols is as object property keys
        <br>

        <h4>Numbers</h4>
        The toFixed() method rounds a number to a fixed number of decimal places:<br>
        The toPrecision() method rounds a number to a fixed number of significant figures<br>

        <h4>Logic Operator</h4>
        !(Logic Not)
        !!(find out if a value it truthy or falsy)
        <br>
        && (Logic And)
        <br>
        ||(Logic Or)
        </p>
    </section>

    <section>
        <h4>Array</h4>
        <p>The shift() method works in a similar way to the pop() method, but this
            removes the first item in the array and the unshift() method is similar to the push() method, but this
            appends a new item to the beginning of the array:
        </p>
        <p>
            Examples:
            <span class="array"></span>
            <br>
            <span class="array2"></span>
        </p>

    </section>

    <section>
        <h4>Sets</h4>
        <p>
            <strong>Notes:</strong>
            A set is a data structure that
            represents a collection of unique values, so it cannot include any duplicate
            values.
        </p>
    </section>

    <section>
        <h4>Maps</h4>
        <p>
            <strong>Notes:</strong>
            Maps a convenient way of keeping a list of key and value pairs, and are similar to
            “hashes”, or“hash tables” or “dictionaries” in other programming languages.
            <br>
            Maps can use any data type as a key.
            <br>
            The value of an object’s properties can be accessed directly, whereas maps restrict you to using the get()
            method to retrieve any values.


        </p>
    </section>

    <section>
        <h4>Logic</h4>
        <p>
            <strong>Notes:</strong>
            A shorthand way of writing an if ... else statement is to use the ternary
            operator, ?
            <br>
            condition ? (//code to run if condition is true) : (//code
            ➥ to run if condition is false)
            <br>
            The switch operator can be used to make your code easier to follow when there
            are lots of conditions to test. The value you are comparing goes in parentheses after the switch operator. A
            case keyword is then used for each possible value that can occur.
            After each case statement is the code that that needs to be run if that case occurs.
            It is important to finish each case block with the <strong>break</strong> keyword, as this stops
            any more of the case blocks being executed. Without a break statement, the
            program will "fall through" and continue to evaluate subsequent case blocks. This
            is sometimes implemented on purpose, but it is a hack and can be confusing. For
            this reason it should be avoided. The default keyword is used at the end for any code than needs to be run
            if none of the cases are true.
            <br>
            A do ... while loop is similar to a while loop. The only difference is that the
            condition comes after the block of code.
            <br>
        </p>
    </section>
    <section>
        <h4>For Loops</h4>
        <p>
            <br>
            <strong>Notes:</strong>
            for (initialization ; condition ; after) { do something }
            <br>
            The initialization code is run before the loop starts and is usually employed to
            initialize any variables used in the loop. The condition has to be satisfied for the
            loop to continue. The after code is what to do after each iteration of the loop, and
            it is typically used to increment a counter of some sort.
            <br>
            A for loop is considered clearer, as all the
            details of the loop (the initialization, condition and increment) are shown in one
            place and kept out of the actual code block.
            <br>
            You can place a loop inside another loop to create a nested loop. It will have an
            inner loop that will run all the way through before the next step of the outer loop
            occurs
            <br>
        </p>
        <h4>Looping over Arrays</h4>
        <p><strong>Notes:</strong>
            Array indices start their numbering at zero, so make sure the value of the initial counter in the for loop
            also starts at zero.
            <br>
            ES6 introduced an improved iterator function for arrays called a for-of loop that
            uses a slightly different syntax: This replaces all of the setup of a ‘for’ loop with a variable
            Fthat represents the value of each element in the array. Note that this
            variable needs to be declared using const.
        </p>
    </section>

    <section>
        <h4>Functions</h4>
        <p>
            <strong>Notes:</strong>
            functions are considered to be first-class objects. This means they
            behave in the same way as all the other primitive data types and objects in the
            language. They can be be assigned to variables, stored in arrays and can even be
            returned by another functions.
            <br>
            Every function has a special variable called <strong>arguments</strong> This is an array-like
            object that contains every argument passed to the function when it is invoked. But, the problem is that
            arguments is not an array
            <br>
            A much better option is to use the rest operator. This was introduced in ES6 and
            can be used to deal with multiple arguments by creating an array of arguments
            that are available inside the body of the function.
            To use the rest operator, simply place three dots in front of the last parameter in a
            function declaration. This will then collect all the arguments entered into an
            array.
            <br>
            Default parameters should always come after non-default parameters, otherwise
            default values will always have to be entered anyway.
            <br>
            The reduce() method is another method that iterates over each value in the
            array, but this time it cumulatively combines each result to return just a single
            value.
            <br>
            The reduce() method also takes a second parameter after the callback, which is
            the initial value of the accumulator, acc
        </p>
    </section>

    <section>
        <h4>Arrow Functions</h4>
        <p>
            <strong>Notes:</strong>
            Arrow functions can be identified by the arrow symbol, => that gives them their
            name. <strong>The parameters come before the arrow and the main body of the function
                comes after</strong>. Arrow functions are always anonymous, so if you want to refer to
            them, you must assign them to a variable


        </p>
    </section>

    <p><span id="date"></span></p>

    <script src="js/script.js"></script>

</body>

</html>