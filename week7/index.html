<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week Seven Futher Function & AJAX</title>
</head>

<body>
    <h2>Week Seven</h2>

    <section>
        <h3>Call & Apple Methods</h3>

        <h4>Notes:</h4>

        <p>
            The call() method can be used to set the value of this inside a function to an
            object that is provided as the first argument.<br>
            If a function doesn’t refer to an object as this in its body, it can still be called
            using the call() method, but you need provide null as its first argument.
        </p>
        <p>
            The apply() method works in the same way, except the arguments of the
            function are provided as an array
        </p>

    </section>

    <section>
        <h3>Custom Properties</h3>

        <h4>Notes:</h4>

        <p>
            There is nothing to stop you adding your own properties to functions in the same
            way that you can add properties to any object in JavaScript.
        </p>

    </section>

    <section>
        <h3>Memoization</h3>

        <h4>Notes:</h4>

        <p>
            A useful feature of this is that it provides result caching, or <strong>memoization</strong>
        </p>
        <p>
            If a function takes some time to compute a return value, we can save the result in
            a cache property. Then if the same argument is used again later, we can return the
            value from the cache, rather than having to compute the result again.
        </p>

    </section>

    <section>
        <h3>Immediately Invoked Function Expressions</h3>

        <h4>Notes:</h4>

        <p>
            An Immediately Invoked Function Expression is an anonymous function that, as the name suggests, is invoked
            as soon as it’s defined. This is easily achieved by placing parentheses at the end of the function
            definition (remember we use parentheses to invoke a function).
        </p>

    </section>

    <section>
        <h3>Initialization Code</h3>

        <h4>Notes:</h4>

        <p>
            An IIFE can be used to set up any initialization code that there’ll be no need for
            again. Because the code is only run once, there’s no need to create any reusable,
            named functions, and all the variables will also be temporary. An IIFE will be
            invoked once, and can set up any variables, objects and event handlers when the
            page loads.
        </p>

    </section>

    <section>
        <h3>Self-contained Code Blocks</h3>

        <h4>Notes:</h4>

        <p>
            An IIFE can be used to enclose a block of code inside its own private scope so it
            doesn’t interfere with any other part of the program.
        </p>

    </section>

    <section>
        <h3>Functions that Define and Rewrite Themselves</h3>

        <h4>Notes:</h4>

        <p>
            The dynamic nature of JavaScript means that a function is able to not only call
            itself, but define itself, and even redefine itself. This is done by assigning an
            anonymous function to a variable <strong>that has the same name as the function.</strong>

        </p>

        <p>
            If any properties have previously been set on the function, these will be lost when
            the function redefines itself.
        </p>

    </section>

    <section>
        <h3>Init-Time Branching</h3>

        <h4>Notes:</h4>

        <p>
            This technique can be used with the feature detection to create functions that rewrite themselves, known as
            init-time branching. This enables the functions to work more effectively in the browser,
            and avoid checking for features every time they’re invoked.<br>
            This can be a useful pattern to initialize functions the first time they’re called,
            optimizing them for the browser being used.

        </p>

    </section>

    <section>
        <h3>Recursive Functions</h3>

        <h4>Notes:</h4>

        <p>
            A recursive function is one that invokes itself until a certain condition is met. It’s
            a useful tool to use when iterative processes are involved.
        </p>

    </section>

    <section>
        <h3>Callbacks</h3>

        <h4>Notes:</h4>

        <p>
            Can also be events such as the completion of a file download, data returned from a database, or the result
            of a complex operation. By using callbacks, we ensure that waiting for these tasks to complete
            doesn’t hold up the execution of other parts of the program. Once the task has
            been completed, the callback will be invoked before returning to the rest of the
            program.
        </p>

    </section>

    <section>
        <h3>Promises</h3>

        <h4>Notes:</h4>

        <p>
            Promises come into their own when multiple asynchronous tasks are required to
            be carried out one after the other. If each function that performs an asynchronous
            operation returns a promise, we can chain the then() methods together to form a
            sequential piece of code that’s easy to read.
        </p>

    </section>

    <section>
        <h3>Async Functions</h3>

        <h4>Notes:</h4>

        <p>
            These functions are preceded by the async keyword and allow you to write asynchronous code as if it
            was synchronous. This is achieved by using the await operator before an asynchronous function.
            This will wrap the return value of the function in a promise that can then be assigned to a variable.
        </p>

    </section>

    <section>
        <h3>Closures</h3>

        <h4>Notes:</h4>

        <p>
            A closure is a reference to a variable that was created inside the scope of another
            function, but is then kept alive and used in another part of the program.
        </p>
        <p>
            One of the key principles in creating closures is that an “inner” function, which
            is declared inside another function, has full access to all of the variables declared
            inside the scope of the function in which it’s declared (the “outer” function).
        </p>
        <p>
            A closure is formed when the inner function is returned by the outer function,
            maintaining access to any variables declared inside the enclosing function.
        </p>
        <p>
            Closures not only have access to variables declared in a parent function’s scope,
            they can also change the value of these variables. This allows us to do things like
            create a counter() function
        </p>

    </section>

    <section>
        <h3>Generators</h3>

        <h4>Notes:</h4>

        <p>
            Are special functions used to produce iterators that maintain the state of a value.
        </p>
        <p>
            To define a generator function, an asterisk symbol (*) is placed after the function
            declaration
        </p>
        <p>
            Calling a generator function doesn’t actually run any of the code in the function;
            it returns a Generator object that can be used to create an iterator that
            implements a next() method that returns a value every time the next() method
            is called.
        </p>
        <p>
            Generator functions employ the special yield keyword that is used to return a
            value. The difference between the yield and the return keywords is that by
            using yield, the state of the value returned is remembered the next time yield is
            called. The execution of the loop is paused after every yield statement, until the
            next() method is called again.
        </p>

    </section>

    <section>
        <h3>Pure Functions</h3>

        <h4>Notes:</h4>

        <ul>
            <ol>
                The return value of a pure function should only depend on the values
                provided as arguments. It doesn’t rely on values from somewhere else in the
                program.
            </ol>
            <ol>
                There are no side-effects. A pure function doesn’t change any values or data
                elsewhere in the program. It only makes non-destructive data transformations and
                returns new values, rather than altering any of the underlying data.
            </ol>
            <ol>
                Referential transparency. Given the same arguments, a pure function will
                always return the same result.
            </ol>
        </ul>

    </section>

    <section>
        <h3>Higher-Order Functions</h3>

        <h4>Notes:</h4>

        <p>
            Higher-order functions are functions that accept another function as an argument,
            or return another function as a result, or both.
        </p>

    </section>

    <section>
        <h3>Ajax</h3>

        <h4>Notes:</h4>

        <p>
            A: Asynchronous - When a request for data is sent, the program doesn’t have to
            stop and wait for the response. It can carry on running,
            waiting for an event to fire when a response is received.<br>
            JA: JavaScript - JavaScript was always considered a front-end language, not
            used to communicate with the server.<br>
            X: XML - XML documents
            were often used to return data. Many different types of data
            can be sent, but by far the most commonly used in Ajax
            nowadays is JSON, which is more lightweight and easier to
            parse than XML.<br>
        </p>

    </section>

    <section>
        <h3>Response Interface</h3>

        <h4>Notes:</h4>

        <p>
            This is based on the HTTP status code3, which can be
            accessed using the <strong>status</strong> property. This will usually be 200 if the response was
            successful, 201 if a resource was created, or 204 when the request is successful
            but no content is returned. The ok property will return true if the status
            property is between 200 and 299. We need to manually check if this happens
            because the promise will only be rejected in the case of a network error, rather
            than something like a “404 page not found error”, which is still considered a
            successful request in terms of the promise. “Forbidden” for a status code of 403.
        </p>
        <ul>
            <li>
                headers – A Headers object (see later section) containing any headers
                associated with the response
            </li>
            <li>
                url – A string containing the URL of response
            </li>
            <li>
                redirected – A boolean value that specifies if the response is the result of a
                redirect
            </li>
            <li>
                type – A string value of “basic”, “cors”, “error” or “opaque”. A value of
                “basic” is used for a response from the same domain. A value of “cors” means
                the data was received from a valid cross-origin request from a different
                domain. A value of “opaque” is used for a response received from “no-cors”
                request from another domain, which means access to the data will be severely
                restricted. A value of “error” is used when a network error occurs.
            </li>
        </ul>

        <p>
            The redirect() method can be used to redirect to another URL. It creates a new
            promise that resolves to the response from the redirected URL.
        </p>
        <p>
            The text() method takes a stream of text from the response, reads it to
            completion and then returns a promise that resolves to a USVSting object that can
            be treated as a string in JavaScript.
        </p>
        <p>
            The blob() method is used to read a file of raw data, such as an image or a
            spreadsheet. Once it has read the whole file, it returns a promise that resolves
            with a blob object.
        </p>
        <p>
            Object.entries() method is used to view the key and value pairs in the
            returned object.
        </p>

    </section>

    <section>
        <h3>Receiving Information</h3>

        <h4>Notes:</h4>

        <p>

        </p>


        <button id='number'>Number Fact</button>
        <button id='chuck'>Chuck Norris Fact</button>
        <div id='output'>
            Ajax response will appear here
        </div>

        <form id='todo' action='https://jsonplaceholder.typicode.com/todos' method='POST'>
            <input type='text' name='task' placeholder='Add Task' autofocus required>
            <button type='submit'>Add Task</button>
        </form>

    </section>

    <section>
        <h3>FormData</h3>

        <h4>Notes:</h4>

        <p>
            A FormData instance is created using a constructor function: const data = new FormData();
        </p>

        <p>
            It’s also possible to add data to the form data instance as key-value pairs using the
            append() method:<br>
            data = new FormData(); // no form provided as an argument creates an empty form data instance<br>
            data.append('height', 75);
        </p>

        <p>
            The FormData interface really comes into its own when a form contains files to
            upload. This was a notoriously difficult task in the past, often requiring the use of
            Flash or another third-party browser plugin to handle the upload process. The
            FormData instance will automatically create the necessary settings required, and
            take care of all the hard work if any file uploads are present in the form.
        </p>

    </section>

    <p><span id="date"></span></p>

    <script src="/week7/js/main.js"></script>

</body>

</html>