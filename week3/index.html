<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week Three Studies on: Objects Methods:this, Objects, DOM, and Events</title>
    <style>
        .highlight {
            color: blueviolet;
        }
    </style>
</head>

<body>
    <h2>Week Three</h2>

    <section>
        <h3>Object methods: this</h3>

        <h4>Notes:</h4>

        <p>
            Objects are usually created to represent entities of the real world, like users, orders and so on.
            And, in the real world, a user can act: select something from the shopping cart, login, logout etc.
            Actions are represented in JavaScript by functions in properties.
        </p>

        <p>
            A function that is a property of an object is called its <strong>method</strong>.
        </p>

        <p>
            To access the object, a method can use the this keyword.
            The value of this is the object “before dot”, the one used to call the method.
        </p>
        <p>
            In JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function,
            even if it’s not a method of an object.
        </p>
        <p>
            In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method
            was declared, but rather on what object is “before the dot”.
        </p>

        <span class=""></span>
    </section>

    <section>
        <h3>Objects</h3>

        <h4>Notes:</h4>

        <p>
            A way to think about an object is that it is like a dictionary where you look up a
            property name and see a value.
        </p>

        <h4>Object Literal</h4>
        <p>
            An object literal is an object that is created directly in the language by wrapping
            all its properties and methods in curly braces {}.
        </p>
        <p>
            All objects are mutable at any time when a program is running. This means that
            its properties and methods can be changed or removed, and new properties and
            methods can be added to the object, even if it was declared using const.
        </p>
        <p>To create an object literal, simply enter a pair of curly braces.</p>
        <p>
            ES6 provided a shorthand method of creating objects if a property key is the same
            as a variable name that the property value is assigned to:
        </p>
        <p>
            Example:<br>
            const name = 'Iron Man';<br>
            const realName = 'Tony Stark';<br>
            const ironMan = { name, realName };
        </p>
        <p>
            You can access the properties of an object using the dot notation (ironMan.name) or bracket notation
            (ironMan['name']
            )
        </p>
        <p>
            An important concept to get your head around is that objects are assigned by
            reference. This means that if a variable is assigned to an object that already exists, it
            will simply point to the exact same space in memory. So any changes made using
            either reference will affect the same object.
        </p>
    </section>

    <section>
        <h3>Computes Properties</h3>

        <h4>Notes:</h4>
        <p>
            The symbols (const realName = Symbol('real name');) used for property keys are not limited to being used
            by only one object - they can be reused by any other object
        </p>
        <p>
            Each symbol has a unique value, which means that using them as property keys
            avoids any naming clashes if you mistakenly use the same value for two different
            property keys. But, be careful
        </p>
    </section>

    <section>
        <h3>Checking if Properties or Methods Exist</h3>

        <h4>Notes:</h4>
        <p>
            Objects can inherit properties from other objects, so all objects have a method
            called hasOwnProperty(). This can be used to check whether an object has a
            property that is its own, rather than one that has been inherited from another
            object
        </p>
        <p>
            This method will only return any properties that belong to that particular object,
            whereas using in or !== undefined will return true, even if the property has
            been inherited from another object
        </p>
    </section>

    <section>
        <h3>Computes Properties</h3>

        <h4>Notes:</h4>
        <p>
            The symbols (const realName = Symbol('real name');) used for property keys are not limited to being used
            by only one object - they can be reused by any other object
        </p>
        <p>
            Each symbol has a unique value, which means that using them as property keys
            avoids any naming clashes if you mistakenly use the same value for two different
            property keys. But, be careful
        </p>
    </section>

    <section>
        <h3>Adding Properties</h3>

        <h4>Notes:</h4>
        <p>
            New properties and methods can be added to objects at any time in a program.
            This is done by simply assigning a value to the new property.
        </p>

    </section>

    <section>
        <h3>Adding Properties</h3>

        <h4>Notes:</h4>
        <p>
            An object literal can be passed as a parameter to a function. This is useful when
            there are a large number of parameters, as it allows the arguments to be provided
            by name and in any order. This means you don’t have to remember the order to
            enter them when invoking a function.

        </p>

    </section>

    <section>
        <h3>Namespacing</h3>

        <h4>Notes:</h4>
        <p>
            Place all our functions inside an object, thereby creating a namespace for them.
        </p>

    </section>

    <section>
        <h3>JSON</h3>

        <h4>Notes:</h4>
        <p>
            JSON is a string representation of the object literal notation that we have just
            seen. There are, however, a couple of key differences:<br>
            1. Property names must be double-quoted<br>
            2. Permitted values are double-quoted strings, numbers, true, false, null, arrays
            and objects<br>
            3. Functions are not permitted values<br>
        </p>

    </section>


    <section>
        <h3>RegExp Methods</h3>

        <h4>Notes:</h4>
        <p>
            A regular expression (or RegExp, for short) is a pattern that can be used to search
            strings for matches to the pattern. A common use is “find and replace” type
            operations.
        </p>
        <p>
            Once you’ve created a regular expression object, you can use the test() method
            to see if a string (passed to the method as a parameter) matches the regular
            expression pattern. It returns true if the pattern is in the string, and false if it
            isn’t.
        </p>
        <p>
            If a \^ character is placed at the start of the sequence of characters with the
            brackets, it negates the sequence (Example: /[^A-Z]/)
        </p>

    </section>

    <section>
        <h3>Regular Expression Properties</h3>

        <h4>Notes:</h4>
        <p>
            Regular expressions are objects, and have the following properties:

            <li>The global property makes the pattern return all matches. By default, the
                pattern only looks for the first occurrence of a match.
            </li>
            <li>
                The ignoreCase property makes the pattern case-insensitive. By default, they
                are case sensitive.
            </li>
            <li>
                The multiline property makes the pattern multiline. By default, a pattern will stop at the end of a
                line.
            </li>


            The following flags can be placed after a regular expression literal to change the
            default properties:
            <li>
                g sets the global property to true
            </li>
            <li>
                i sets the ignoreCase property to true
            </li>
            <li>
                m sets the multiline property to true
            </li>
        </p>

    </section>

    <section>
        <h3>Special Characters</h3>

        <h4>Notes:</h4>
        <p>
            In a regular expression, there are a number of characters that have a special
            meaning, commonly known as metacharacters:

            <li>
                . matches any character, except line breaks
            </li>
            <li>
                \w matches any word character, and is equivalent to [A-Za-z0-9_]
            </li>
            <li>
                \W matches any non-word character, and is equivalent to [\^A-Za-z0-9_]
            </li>
            <li>
                \d matches any digit character, and is equivalent to [0-9]
            </li>
            <li>
                \D matches any non-digit character, and is equivalent to [^0-9]
            </li>
            <li>
                \s matches any whitespace character, and is equivalent to [ \t\r\n\f]
            </li>
            <li>
                \S matches any non-whitespace character, and is equivalent to [^ \t\r\n\f]

            </li>
        </p>

    </section>


    <section>
        <h3>Modifiers</h3>

        <h4>Notes:</h4>
        <p>
            Modifiers can be placed after a token to deal with multiple occurrences of that
            token:
            <li>
                ? makes the preceding token in the regular expression optional
            </li>
            <li>
                * matches one or more occurrences of the preceding token
            </li>
            <li>
                + matches one or more occurrences of the preceding token
            </li>
            <li>
                {n} matches n occurrences of the preceding token
            </li>
            <li>
                {n,} matches at least n occurrences of the pattern
            </li>
            <li>
                {,m}matches at most m occurrences of the preceding token
            </li>
            <li>
                {n,m} matches at least n and at most m occurrences of the preceding token
            </li>
            <li>
                ^ marks the position immediately before the first character in the string
            </li>
            <li>
                $ marks the position immediately after the last character in the string
            </li>
        </p>

    </section>

    <section>
        <h3>DOM</h3>

        <h4>Notes:</h4>
        <p>
            All nodes have a numerical code to signify what type they are:
            <li>1 - element</li>
            <li>2 - attribute</li>
            <li>3 - text</li>
            <li>8 - comment</li>
            <li>9 - body</li>
        </p>
        <p>
            There are some methods from DOM Level 0 that can still be employed to access
            commonly used elements. These include:
            <li>
                Document.body returns the body element of a web page.
            </li>
            <li>
                Document.images returns a node list of all the images in the document.
            </li>
            <li>
                Document.links returns a node list of all the "a" elements and "area"
                elements that have an href attribute.
            </li>
            <li>
                Document.anchors returns a node list of all the "a" elements that have a name
                attribute.
            </li>
            <li>
                Document.forms returns a node list of all the forms in the document.
            </li>
        </p>
        <p>
            Node lists are array-like objects, but they are not arrays. You can access each item
            using index notation. For example, document.images[0] will return the first
            image in the node list of all the images in the document.
            They also have a length property, which can be used to iterate through every
            element using a for loop
        </p>
        <p>
            Node lists don’t have any other array methods such as slice, splice and join.
            ES6 makes it very easy to turn a node list into an array, however. You can either use
            the Array.from() Or you can use the spread operator. Once the node list has been turned into an array, you
            can use all the array methods
            on it.

        </p>
    </section>

    <section>
        <h3>Get Elements By Their Tag Name</h3>

        <h4>Notes:</h4>
        <p>
            getElementsByTagName() will return a live node list of all the elements with the
            tag name that is provided as an argument. For example, we can get all the list
            items (HTML tag of "li") in the document using this code:
            const listItems = document.getElementsByTagName('li');
        </p>
        <p>
            The querySelector() method can be called on any element, rather than just
            document. For example, we can get a reference to the "ul" element
        </p>
        <p>
            we can use the querySelector() method on this element, to find a "li"
            element with an id of 'bats': const ul = document.querySelector('ul#roster');
            const batman = ul.querySelector('li#bats');
        </p>
    </section>

    <section>
        <h3>Setting An Element’s Attributes</h3>

        <h4>Notes:</h4>
        <p>
            The setAttribute can change the value of an element’s attributes. It takes two
            arguments: the attribute that you wish to change, and the new value of that
            attribute.
            For example, if we wanted to change the class of the element in the wonderWoman
            variable to villain, we could do so using this code:
            wonderWoman.setAttribute('class', 'villain'); wonderWoman.getAttribute('class');
        </p>
    </section>

    <section>
        <h3>The classList Property</h3>

        <h4>Notes:</h4>
        <p>
            The toggle method is a particularly useful method that will add a class if an
            element doesn’t have it already, and remove the class if it does have it. It returns
            true if the class was added and false if it was removed.
        </p>
        <p>
            The appendChild() and insertBefore() methods can be used to move markup
            that already exists in the DOM as well. This is because a reference to a single
            DOM element can only exist once in the page, so if you use multiple inserts and
            appends, only the last one will have an effect. If an element is required to appear
            in several different places in the document, it would need to be cloned before
            each insertion.

        </p>
    </section>

    <h4 id='title'>Justice League</h4>

    <ul id='roster'>
        <li class='hero'>Superman</li>
        <li class='vigilante hero' id='bats'>Batman</li>
        <li class='hero'>Wonder Woman</li>
    </ul>


    <section>
        <h3>Events Listeners</h3>

        <h4>Notes:</h4>
        <p>
            The click event occurs when a user clicks with the mouse, presses the Enter key,
            or taps the screen, making it a very useful all-round event covering many types of
            interaction.

        </p>
        <p>
            Inline Event Handler: onclick="console.log('You Clicked Me!')">Click Me
        </p>
        <p>
            Only one event handler for each event-type can be attached to an element.
        </p>
        <p>
            Older Event Handlers: document.onclick = function (){ console.log('You clicked on the page!'); }
        </p>
        <p>
            Event listeners first parameter is the type of event, and the second is a callback function that
            is invoked when the event occurs. The third type of event is "capture".boolean.
        </p>

        <p id='click'>Click On Me</p>
        <p id='dblclick'>Double Click On Me</p>
        <p id='mouse'>Hover On Me</p>
    </section>

    <section>
        <h3>Mouse Events</h3>

        <h4>Notes:</h4>
        <p>
            Different types of mouse events:
            <li> click</li>event that occurs when a mouse button is
            clicked.
            <li>mousedown</li>occur
            before a click event is fired.
            <li>mouseup</li>occur
            before a click event is fired.
            <li> dblclick</li> occurs when the user doubleclicks on
            the element to which the event listener is attached.
            <li> mouseover</li>event occurs when the mouse pointer is placed over the element
            to which the event listener is attached

        </p>
    </section>

    <section>
        <h3>Keyboard Events</h3>

        <h4>Notes:</h4>
        <p>
            Different types of keyboard events:
            <li>keydown</li> event occurs when a key is pressed and will continue to occur if
            the key is held down.

            <li>keypress</li>event occurs after a keydown event but before a keyup event
            <li>keyup</li> event occurs when a key is released.
        </p>
    </section>

    <section>
        <h3>Touch Events</h3>

        <h4>Notes:</h4>
        <p>
            Different types of touch events:
            <li> touchstart</li> event occurs when a user initially touches the surface.

            <li> touchend</li> event occurs when a user stops touching the surface.
            <li> touchmove</li> event occurs after a user has touched the screen then moves
            around without leaving.
            <li> touchenter</li> event occurs when a user has already started touching the
            surface, but then passes over the element to which the event listener is attached.
            <li> touchleave</li>event occurs when the user is still touching the surface, but
            leaves the element to which the event listener is attached.
            <li>touchcancel</li> event occurs when a touch event is interrupted, such as a user’s
            finger moving outside the document window, or too many fingers being used at
            once. A pop-up dialog will also cancel a touch event.

        </p>
    </section>

    <section>
        <h3>Stopping Default Behavior</h3>

        <h4>Notes:</h4>
        <p>
            An event listener can be removed using the removeEventListener() method
        </p>
        <p id='once'>A One Time Thing...</p>

    </section>

    <section>
        <h3>Removing Event Listeners
        </h3>

        <h4>Notes:</h4>
        <p>
            Some elements have default behavior associated with certain events. For
            example, when a user clicks on a link, the browser redirects to the address in the
            href attribute and a form is submitted when the user clicks on the Submit button.
        </p>
        <p>
            <a id='broken' href='https://sitepoint.com'>Broken Link</a>
        </p>


    </section>
    <span class=""></span>

    <p><span id="date"></span></p>

    <script src="js/script.js"></script>

</body>

</html>